---
title: Hands off! An attempt at a mouseless work-flow with Gnu Screen
layout: post
published: false
---
h2. Hands off! An attempt at a mouseless work-flow with Gnu Screen

p(section-title). What's screen? Why this tutorial?

Screen is a program that brings the idea of windows to the console/terminal. The man page states that 'Screen  is  a full-screen window manager...', but for the purposes of this experiment, it's enough to know that it has the concept of windows and that once started, gnu screen can be disconnected from and reconnnected to at will, with previously running programs left uninterrupted.

Perhaps the most immediate motivation for using screen, is that it can be started remotely, where the above-mentioned features can be taken advantage of to allow one to start long running programs without the risk of having them killed once the network connection with the server is broken.

Here's an example of one my typical screen sessions that takes advantage of this functionality:

p(code). [my_computer] $ ssh someserver.com
[their_puter] $ screen
[their_puter] $ rake import:really_huge_db_dump
starting import of 1.5 GB sql dump
 ^A ^D
[detached]
[their_puter] $ exit
Connection to someserver.com closed
[my_computer] $

...time passes...

p(code). [my_computer] $ ssh someserver.com
[their_puter] $ screen -r
[their_puter] $ rake import:really:huge:db_dump
starting import of 1.5 GB sql dump
finished import of 1.5 GB sql dump. Took 15 hours.
[their_puter] $

p. The motivation for this experiment simply came after discovering screen and wondering if I could eliminate reaching for the mouse while I'm programming. I don't use the mouse much to begin with and I find that it interrupts my work flow when I do have to reach for it.

p(section-title). Next steps, going beyond the basics.

p. The sample session above is dead simple. I learned it the first day and although it solved a concrete problem for me, it didn't get me far beyond wondering IF it could be used in terms of this experiment. So what's the next step?

p. Well what I mainly do in the terminal is run programs and watch output (e.g. log files, rails servers, rails console, etc.). In a typical environment with windows, my editor is usually in one window and can be switched to with @alt + tab@, so if you're running your editor in a screen session, how do you "@alt + tab@" to your log output?

p(section-title). Windows

This is where screen's ability to manage windows comes in. In screen you can get another window by pressing @^a ^c@. In screen, @^a@ is typically used in conjunction with some other character to tap into Gnu screen specific commands. So @^a ^c@ creates new windows, but cycling through them is done with @^a ^n@ and @^a ^p@, respectively.

On the one hand this does solve the problem of doing two things within one screen session, but most terminal programs have tabbing capabilities and ways of cycing through those tabs without using the mouse. So does screen offer anything to sweeten the deal?

Well for starters, a screen window can be split, i.e. two windows are displayed at the same time, meaning that you can input commands on one side and, for instance, tail that log on the other side. I'll get into split-screen screen at the end because there are some caveats to consider that would be better addressed once some experience with screen was gained

I know that other terminal emulators offer split-screen too, but it's nice to see that screen offers it, so the experiment goes on.

|_.Description|_.Command|
(even). |New window   | @^a ^c@   |
(odd). |Previous window| @^a ^p@ |
(even). |Next window|@^a ^n@ |

p(section-title). Some configuration

I discovered something else. Screen is pretty configurable. For instance, you don't really get an overview of your windows as you create them
in screen. This can be a little disorienting as you're learning screen and start experimenting with more than just one second window.

Luckily I found this config:

p(code). $ cat ~/.screenrc
hardstatus alwayslastline
hardstatus string '%{= kG}[ %{G}%H %{g}][%= %{=kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B}%Y-%m-%d %{W}%c %{g}]'
$

This will get you something like this at the bottom of each one of your screen windows

<pre class='code' id=task-bar> [ (none) ][       0$ bash  1$ bash  2-$ bash  (3*$bash)         ][2011-03-07 18:16 ] </pre>

It's easy to see that this is more or less the equivalent of a console based windows panel. In the middle you see that there art four (bash)
windows and that @(3*$bash)@ is the active one. You even get a clock on the right.

|_.Description|_.Command|
(even). | Goto window <number>  | @^a <number>@   |

p(section-title). Working with the console output

I mentioned above that I mainly run programs and tail log files in the terminal. At this point I know how to do both at the same time in one screen session by taking advantage of its windowing functionality, but I quickly realized that this came at a cost: scrolling with the mouse ceases to work.

This is probably the one thing that I did enjoy doing with the mouse. Scrolling up and down through the terminal with the flip of a finger
is a great way to look through terminal output, especially if you're looking for a specific pattern (i.e. error messages), so I guess it never really felt like something that affected my work flow. Now that I was without it, it felt like something was missing.

p(section-title). Copy-mode to the rescue

I discovered that 'scrolling' is accomplished in screen by entering copy-mode.

By pressing @^a ^[@ you enter 'copy-mode' in screen, which allows you to navigate the screen content as if it were a vim or emacs buffer,
in fact, you even navigate the buffer with vim key bindings (i.e. h,j,k,l). At first this felt like a somewhat sluggish and unsatisfactory way of reviewing command output, but I soon discovered that it actually offered some real advantages and once I overcame the inertia of trying to scroll with the mouse, I actually took to it pretty well and would even say that going back to old style mouse scrolling in regular terminal sessions felt like there was something missing. I'll explain that in just a bit.

So, as I said, @^a ^[@ gets you copy mode in screen and after you're in copy-mode, you navigate the buffer with vim key bindings. h,j,k and l move you left, down, up and right one unit respectively and @c-u@ and @c-d@ page up and page down respectively. That's really all the scrolling I need. @esc@ gets you out of copy-mode and back to your prompt, ready to type commands normally.

|_.Description|_.Command|
(even). | enter copy-mode  | @^a [@   |
(odd). | left, up, down, right  |h,j,k,l    |
(even). | page-up  | @^u@   |
(odd). | page-down  | @^d@   |

p(section-title). Extra benefits of copy-mode

I mentioned that after spending some time with copy-mode, going back to regular terminal output navigation with the mouse actually felt like it was missing something. Well, that 'something' is that in screen copy-mode, is not just limited to navigating, it's also great for (you guessed it) copying.

After navigating to various parts of the buffer as highlighted above, the @space@ bar activates highlighting. You then navigate to another part of the buffer, press @space@ again, and you've got everything in the highlighted reqion copied. Now pressing @^a^]@ in any program in any window within your screen session (mutt, ttytter, emacs, vim, etc.) pastes the content. I really found this to be a great feature. Whatever small discomforts there might have been when I first started working with program output like this were well surpassed by this feature.

|_.Description|_.Command|
(even). | mark beginning of region  | space |
(odd). | copy highlighted region  | space  |
(even). | paste  | @ctrl-]@ |

p(section-title). Extras

One final thing I tried was the concept of split screen screen sessions. I won't spend too much time on it because my experience with it involved a patched copy of screen that hasn't been officially released yet. Basically,
