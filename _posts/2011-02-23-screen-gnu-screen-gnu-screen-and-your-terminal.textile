---
title: Hands off! An attempt at a mouseless work-flow with Gnu Screen
layout: post
---

h2. What's screen? Why this tutorial?

Screen is a program that brings the idea of windows to the console/terminal. The man page states this in stronger words ('Screen  is  a full-screen window manager...'), but for the sake of this tutorial, that's not important. Gnu-screen is a great tool and we're going to focus on getting you working quickly and without overloading you with the technical stuff at the beginning.

It should be stated though that technical terms will not be left out all together, I actually have a predilection for technical arcana and minutiae, but that's another blog post. The technical stuff will just be avoided in the beginning and introduce only as really needed. The documentation for screen is quiet good, but it also helps to get some overhead out of the way first, i.e. simply using it.

So, now that we've introduced screen, let give my concrete motivation for starting with screen: Simply put, I wanted (needed) to do the following:

1. log into some server.com...nothing new
3. issue really long running command
4. ***disconnect without killing process ***
5. ***reconnect 15 hours later to see that the process has finished ***

This is exactly what screen allows you to do. Here's what such a screen session might look like in the terminal:

<div class="code">

bc. [my_computer] $ ssh someserver.com
 [their_puter] $ screen
 [their_puter] $ rake import:really:huge:db_dump
 starting import of 1.5 GB sql dump
  ^A ^D
 [detached]
 [their_puter] $ exit
 Connection to someserver.com closed
 [my_computer] $ 

</div>

...time passes...

<div class="code">

bc. [my_computer] $ ssh someserver.com
 [their_puter] $ screen -r
 [their_puter] $ rake import:really:huge:db_dump
 starting import of 1.5 GB sql dump
 finishing import of 1.5 GB sql dump. Took 15 hours.
 [their_puter] $

</div>

At the beginning, that was enough for me and the relevant commands at the moment are simply 'screen', a variation of screen, 'screen -r', 'control-a' and 'control-d'.

Every tutorial you read though makes promises about how much more screen can do and it was only a matter of time before curiosity had me looking at what that was. Unfortunately, there aren't ***a lot *** of tutorials that guide you through that though, at least not that I was satisfied with.

So let's consider the next thing that came to mind at that time: "Wouldn't it be great if every ssh session could automatically be a screen session???" Well, here's a way to do that

<div class="code">

bc. $ echo 'alias ssh='ssh -t screen -R' >> ~/.bashrc

</div>


after this moment of inspiration, I actually wanted more. Let's take the next step and decide that we actually want to have a screen session for every one of our ssh sessions so that if we find ourselves actually issuing an unanticipated long command at the end of the day, we won't be forced to kill it just so that we an go home.


This creates an alias so that 'ssh' fires up the screen command upon login. The @-R@ option simply means find the first available screen session (there can be multiple screen sessions at once) and connect to it. If you don't find one to connect to, start a new one.

There are numerous reasons for which this is actually not a recommended way of making ssh sessions also log into screen, but I won't go into them because it works for the sake of this tutorial, it's similar to the approach I took (I actually create a simple bash script), and it's also doesn't pose any real dangers.

So now in principle, we're set up to have every ssh session also be a screen session, meaning that we don't have to know ahead of time if you're going to be running long-running commands that keep you late at work, or force you to kill the job.

Good.

h3. Next steps, going beyond the basics.

p. The sample session above is dead simple. I learned it the first day and although it solved a concrete problem for me, it didn't get me far
beyond wondering IF it could be used in terms of this experiment. So what's the next step?

p. Well what I mainly do in the terminal is run programs and watch output (e.g. log files). My editor is usually in another window and that can
be switched to with @alt + tab@, so if you're running a program in your screen session, then you can't tail a log file at the same time, right?

h3. Windows

This is where screen's ability to manage windows comes in. In screen you can get another window by pressing @^a ^c@. @^a ^n@ and @^a ^p@ can
be used to cycle backward and forward through the windows. On the one hand this does solve the problem of doing two things within one screen
session, but most terminal programs have tabbing capabilities and ways of cycing through those tabs without using the mouse. So does screen
offer anything to sweeten the deal?

Well for starters, a screen window can be split, i.e. two windows are displayed at the same time, meaning that you can input commands on one
side and, for instance, tail that log on the other side.

Pretty sweet. I know that other terminal emulators offer this too, but it's nice to see that screen offers this as well as things that other
terminals don't. The experiment goes on

h3. Some configuration

<div class="code">

bc. $ dmesg | tail -10
PM: resume of devices complete after 3058.648 msecs
PM: Finishing wakeup.
Restarting tasks ... done.
video LNXVIDEO:01: Restoring backlight state
ADDRCONF(NETDEV_UP): wlan0: link is not ready
e1000e 0000:00:19.0: irq 46 for MSI/MSI-X
e1000e 0000:00:19.0: irq 46 for MSI/MSI-X
ADDRCONF(NETDEV_UP): eth0: link is not ready
iwlagn 0000:03:00.0: TX Power requested while scanning!
iwlagn 0000:03:00.0: Error sending TX power (-11)
$ ^a ^[ kkkkkkkkkk0<space>jjjjjjjjj<space>^a^]

</div>

in case that looks like non-sense, I pressed C-a C-[ then the 'k' button 10 times, the space button then the '0' button once, the 'j' button 9 times and then the space bar again.

This will get you something like this at the bottom of each one of your screen windows

bc. [ (none) ][            0$ bash  1$ bash  2-$ bash  (3*$bash)                 ][2011-03-07 18:16 ]

It's easy to see that this is more or less the equivalent of a console based windows panel. In the middle you see that there art four (bash)
windows and that @(3*$bash)@ is the active one. You even get a clock on the right.

h3. Working with the console output

I mentioned above that I mainly run programs and tail log file in the terminal. At this point I know how to do both at the same time in one
screen session by taking advantage of its windowing functionality, but I quickly realized that this came at a cost: scrolling with the mouse
ceases to work.

<div class="code">

bc. $ cat ~/.screenrc
hardstatus alwayslastline
hardstatus string '%{= kG}[ %{G}%H %{g}][%= %{=kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B}%Y-%m-%d %{W}%c %{g}]'
$

</div>

What this does is set up your screen sessions so that you have the console equivalent of a taskbar at the bottom of your screen. My current 'taskbar' looks as follows:

<div class="code">

bc. [ (none) ][            0$ bash  1$ bash  2-$ bash  (3*$bash)                 ][2011-03-07 18:16 ]

</div>

Don't ask me what the @[ (none) ]@ on the left means, I haven't figured it out, but the four 'bash' fields represent the four windows that I have open. @(3*$bash)@ is the current active window. @C-a C-n@ and @C-a C-p@ choose the next window and the previous window respectively.
