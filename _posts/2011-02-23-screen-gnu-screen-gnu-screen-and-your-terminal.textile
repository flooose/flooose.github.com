---
title: Screen, GNU-Screen, GNU-Screen and you and your Terminal
layout: post
---

h3. What's screen? Why this tutorial?

p. Screen is a program that brings the idea of windows to the console/terminal. The man page states this in stronger words ('Screen  is  a full-screen window manager...'), but this tutorial is written to get people running quickly and without all the technical stuff at the beginning because screen is a great tool, but one that took me entirely too long to master on a level that allowed me to practically use it for most of my needs.

And that's exactly why I'm writing this tutorial: everyone can use it in their day-to-day programming lives. If you work in the console, you should use screen. And you should use a console; you don't program in and IDE do you???

It should be stated though that technical terms will not be left out all together, I actually have a predilection for technical arcana and minutiae. The technical stuff will just be avoided in the beginning and introduced only as really needed. The documentation for screen is quiet good, but it also helps to get some overhead out of the way first, i.e. simply using it.

So, I've introduced my motivation and sang the praises of screen, but I feel like it's necessary to give a concrete example of why to use screen. Simply put, screen allows you do do the following:

bc. [my_computer] $ ssh someserver.com
[their_puter] $ screen
[their_puter] $ rake import:really:huge:db_dump
starting import of 1.5 GB sql dump
 ^A ^D
[detached]
[their_puter] $ exit
Connection to someserver.com closed
[my_computer] $

...time passes...

bc. [my_computer] $ ssh someserver.com
[their_puter] $ screen -r
[their_puter] $ rake import:really:huge:db_dump
starting import of 1.5 GB sql dump
finishing import of 1.5 GB sql dump. Took 15 hours.
[their_puter] $

That's not exactly what the code looks like, although you'll see everything I've listed. This can essentially be wrapped as follows:

1. log into some server.com...nothing new
2. issue screen command, i.e. start screen
3. issue really long running command
4. ***disconnect without killing process***
5. ***reconnect 15 hours later to see that the process has finished***

So for me that was enough motivation to use screen. Every tutorial you read though makes promises about how much more screen can do. What they don't do is approach it from I consider to be the right angle, i.e. getting things done (in our domain, I should probably add.

So after this moment of inspiration, I actually wanted more. Let's take the next step and decide that we actually want to have a screen session for every one of our ssh sessions so that if we find ourselves actually issuing an unanticipated long command at the end of the day, we won't be forced to kill it just so that we an go home.

bc. $ echo 'alias ssh='ssh -t screen -R' >> ~/.bashrc

This creates an alias so that 'ssh' fires up the screen command upon login. The @-R@ option simply means find the first available screen session (there can be multiple screen sessions at once) and connect to it. If you don't find one to connect to, start a new one.

There are numerous reasons for which this is actually not a recommended way of making ssh sessions also log into screen, but I won't go into them because it works for the sake of this tutorial, it's similar to the approach I took (I actually create a simple bash script), and it's also doesn't pose any real dangers.

So now in principle, we're set up to have every ssh session also be a screen session, meaning that we don't have to know ahead of time if you're going to be running long-running commands that keep you late at work, or force you to kill the job.

Good.

But guess what, now that you're looking at your screen session, I hope you don't need to look at your command output, because screen trampled my console's ability to scroll.

Crap.

Well, googling will get you the answer, but since our intent is to get you using screen quickly, I'll give it to you here:

When using screen, C-a C-[ gets you into scroll (a.k.a copy) mode. Now you've got vim bindings to scroll up and down. This isn't a vim tutorial, so I won't go into its bindings, I can give those who aren't in the know a hint though: h,j,k,l.

Okay, scrolling isn't really ideal in screen, if you've gotten used to wooshing past lines of code with the scroll-wheel on your mouse, but vim allows for some good alternatives and I have to say, that after taking some time to work with it, I actually felt very unhindered.

So here's what you need to know about reviewing your output.

1. C-a C-[ gets you into copy-mode.
2. scrolling is done with the typical vim keys (start with h,j,k,l)
3. working with the output can't be done with the mouse and involves highlighting and copying. Here's how you do that
   1. follow steps 1 and 2 from above
   2. set two marks
   3. C-a C-] copies what between the two marks.

Since this tutorial is meant as a practical introduction, I'm going to assume that the most you're going to do with the output, aside from reading it, is copying full lines to paste some place else. Here's a sample session of what you can do with this:

bc. $ dmesg | tail -10
PM: resume of devices complete after 3058.648 msecs
PM: Finishing wakeup.
Restarting tasks ... done.
video LNXVIDEO:01: Restoring backlight state
ADDRCONF(NETDEV_UP): wlan0: link is not ready
e1000e 0000:00:19.0: irq 46 for MSI/MSI-X
e1000e 0000:00:19.0: irq 46 for MSI/MSI-X
ADDRCONF(NETDEV_UP): eth0: link is not ready
iwlagn 0000:03:00.0: TX Power requested while scanning!
iwlagn 0000:03:00.0: Error sending TX power (-11)
$ ^a ^[ kkkkkkkkkk0<space>jjjjjjjjj<space>^a^]

in case that looks like non-sense, I pressed C-a C-[ then the 'k' button 10 times, the space button then the '0' button once, the 'j' button 9 times and then the space bar again.

Now with that out of the way, I can actually open my favorite editor (emacs) in the terminal and then actually copy the text into there.

Okay, so running screen and coming to grips with dealing with the output differently are taken care of. What next?

Well, a screen session is cool, but what if you want another terminal open on the same server, say, to tail a log file while you try different things in the original terminal. Do you really have to clutter your workspace with another window and start another screen session in a new ssh session just to be able to take advantage of the features of screen?

No.

Gnu-Screen has the concept of windows. Before we get into that though, lets take a moment to reflect on the fact that we want to keep this introduction topical. In order to make the learning of screen's concept of windows as painless as possible, we're going to add a config entry into @~/.screenrc@:

bc. $ cat ~/.screenrc
hardstatus alwayslastline
hardstatus string '%{= kG}[ %{G}%H %{g}][%= %{=kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B}%Y-%m-%d %{W}%c %{g}]'
$

What this does is set up your screen sessions so that you have the console equivalent of a taskbar at the bottom of your screen. My current 'taskbar' looks as follows:

bc. [ (none) ][            0$ bash  1$ bash  2-$ bash  (3*$bash)                 ][2011-03-07 18:16 ]

Don't ask me what the @[ (none) ]@ on the left means, I haven't figured it out, but the four 'bash' fields represent the four windows that I have open. @(3*$bash)@ is the current active window. @C-a C-n@ and @C-a C-p@ choose the next window and the previous window respectively.

