---
title: Exploring rvm's bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)
layout: post
published: false
---

I've not done a lot of shell scripting, but I've done enough to wish I knew how to do it better. Since my day-to-day work doesn't take me beyond the basic scripts that I've written, I try to take advantage of any opportunity to pick up a little more knowlege about it.

That's what this post is going to be about.

If you've intalled Wayne Seguin's excellent Ruby version manager (rvm) recently, there's a pretty good chance that you executed the following

p(code). love-hacker $ bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)

Well, the @bash@ part of it is pretty straight forward for me, and so is the @<@. The @curl -s https://rvm.beginrescueend.com/install/rvm@ is also obviously a command being executed. What's no so clear though, is why it's executed from within @<()@. Let's dig in!

You don't have to read far into the bash manpage before you stumble upon the section@Compound Commands@

Among the things mentioned in this section is the following:

p(code). (list) list  is  executed in a subshell environment (see COMMAND EXECUTION ENVIRONMENT below).  Variable assignments and builtin commands that affect the shell's environment do not remain in effect after the command completes.  The return status is the exit status of list.

playing the 'recursive dictionary' game, we need to look up what a 'list' is. Good thing that was mentioned just above in the appropriatly named section 'Lists'. A list is a :

p(code). A list is a sequence of one or more pipelines separated by one of the operators ;, &, &&, or ||, and optionally terminated by one of ;, &, or <newline>.

Okay, we could go on playing the 'recursive dictionary' game and look up 'pipeline', but for simplicity, we'll just spill the beans and mention that a 'pipeline' is exactly what we expect: @$ cat some_huge.file | grep 'ordinary_word'@ . There are other pipelines, but I think everyone is familiar with this pattern, and it's sufficient to mention that a single command also counts as a pipeline.

So let's move on. We now know that our command @curl@ is being executed in a subshell.

My understanding of the @<@ directly in front of the subshell command now seems a bit limited. I've generally used the @<@ operator in situations similar to the following:

p(code). love-hacker $ mysql -u username database_name < sql_dump.sql

where @sql_dump.sql@ is always a file name. If I take this example and think of @< sql_dump.sql@ to mean, "feed a bunch of text to the @mysql@ command", then the  @<(curl -s https://rvm.beginrescueend.com/install/rvm)@ could also be seen as feeding a bunch of text to something, but what?

The magic is @...< <(...@

I did a little exercise:

p(code). love-hacker $ cat ~/rvm_fun
echo '##### LISTING DIRECTORY CONTENTS #####'
ls
love-hacker $ bash rvm_fun
##### LISTING DIRECTORY CONTENTS #####
Desktop		Downloads	Library		Movies		Pictures	Public		VirtualBox VMs	hardcopy.0	pgadmin.log	trash
Documents	Dropbox		Mail		Music		Projects	Sites		alpm_ruby	nina		rvm_fun
love-hacker $ bash <(cat rvm_fun)
##### LISTING DIRECTORY CONTENTS #####
Desktop		Downloads	Library		Movies		Pictures	Public		VirtualBox VMs	hardcopy.0	pgadmin.log	trash
Documents	Dropbox		Mail		Music		Projects	Sites		alpm_ruby	nina		rvm_fun
love-hacker $ bash < <(cat rvm_fun)
##### LISTING DIRECTORY CONTENTS #####
Desktop		Downloads	Library		Movies		Pictures	Public		VirtualBox VMs	hardcopy.0	pgadmin.log	trash
Documents	Dropbox		Mail		Music		Projects	Sites		alpm_ruby	nina		rvm_fun

So, I saved some commands in @rvm_fun@ and used two different forms of file redirection. First I did it the way that looked more familiar to me, i.e. like the sql_dump example above. Surprisingly, it work. Next I tried it their way, which yielded the same result.

This made me curious, and just to make sure that indeed works the same, I fired up a virtual machine and ran their exact install command. The results were the same.

I did notice just one (very) slight difference, and that was running their command without an internet connection. The only difference however, was that upon failure, their comand outputted and empty line before returning me to the prompt, while mine just returned right to the prompt.

I suspected that all of this was covered in the @REDIRECTION@ section of the man page. I had spent some time reading it and most of that stuff and decided that I just didn't get it all, so I experimented with the different versions of the command. There was one more thing I could do to make my version of the rvm command, @bash <(cat rvm_fun)@ look more like my version of the sql command, @mysql -u username database_name < sql_dump.sql@. What happens if my version of the rvm command has a space after @<@, like in the sql command:

p(code). love-hacker $ bash < (cat rvm_fun)
-bash: syntax error near unexpected token `('

Aha! So there is some deeper difference between the sql command that I've known so long and the rvm command, which (sort) of looks like it. And to understand it, I do indeed need to get a better understanding for input/output redirection.

The first order business was getting an understanding for file descriptors. Here again, I felt that I had an intuition about what they were, but based on the issues I was running into above, I realized that I needed a more concrete understanding for what they actually are. For this, I had to cheat a little and turn a way from the bash man page. I turned my attention the @Advanced Bash-Scripting Guide@, an excellent book that is freely available on the internet.

Chapter 19 of @Advanced Bash-Scripting Guide@ concretely states:

bc. A file descriptor is simply a number that the operating system assigns to an open file to keep track of it. Consider it a simplified type of file pointer. It is analogous to a file handle in C.

Great. This is in sync with my intuition about what a file descriptor is. Within the same chapter, I was also reminded that that stdin, stdout, and stderr also have file descriptors. This seems like it could be important later on.

Chapter 19 was quite interesting, and I would say, give it a read, but I didn't find my solution. I got a little further when I stumbled over Chapter 22 @Process Substitution@. There it was in black and white: the @<(some_command)@ construct actually is actually a central part of bash, not a composite of separate parts. It goes on to point out a some things specific to this post. First, @bash <(rvm_fun)@ is the same as @cat rvm_fun | bash@, which explains why my version of the rvm command worked. So why @bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)@ instead of simply @bash <(curl -s https://rvm.beginrescueend.com/install/rvm)@?

Chapter 22 goes further. It gives other examples of "Process Subsitution" uses. One specific example stands out:

p(code). read -a list < <( od -Ad -w24 -t u2 /dev/urandom )
# Read a list of random numbers from /dev/urandom,
# process with "od"
# and feed into stdin of "read" . . .

So the @bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)@ feeds the output of the curl command into the stdin of "bash", i.e. it redirects it to the stdin of the "bash" command, while the @bash <(curl -s https://rvm.beginrescueend.com/install/rvm)@ presents it as a command line argument to the "bash" command.